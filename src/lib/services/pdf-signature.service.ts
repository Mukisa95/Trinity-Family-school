"use client";

import { DigitalSignatureService } from './digital-signature.service';
import { useRecordSignatures } from '../hooks/use-digital-signature';
import type { 
  RecordType, 
  DigitalSignature, 
  AuditTrailEntry 
} from '@/types/digital-signature';

export interface PDFSignatureOptions {
  recordType: RecordType;
  recordId: string;
  includeActions?: string[];
  position?: 'header' | 'footer' | 'custom';
  customPosition?: { x: number; y: number };
  fontSize?: number;
  color?: string;
  showTimestamp?: boolean;
  showUserRole?: boolean;
  maxSignatures?: number;
}

export interface PDFSignatureData {
  signatures: AuditTrailEntry[];
  formattedText: string[];
  htmlSignatures: string[];
}

export class PDFSignatureService {
  /**
   * Get signatures for a record and format them for PDF inclusion
   */
  static async getSignaturesForPDF(
    recordType: RecordType,
    recordId: string,
    options: Partial<PDFSignatureOptions> = {}
  ): Promise<PDFSignatureData> {
    try {
      const signatures = await DigitalSignatureService.getSignaturesForRecord(recordType, recordId);
      
      if (!signatures || signatures.length === 0) {
        return {
          signatures: [],
          formattedText: [],
          htmlSignatures: []
        };
      }

      const {
        includeActions = ['created', 'updated', 'payment', 'collection'],
        maxSignatures = 5,
        showTimestamp = true,
        showUserRole = true
      } = options;

      // Filter signatures by actions
      const filteredSignatures = signatures.filter(sig => 
        includeActions.some(action => sig.action.toLowerCase().includes(action.toLowerCase()))
      ).slice(0, maxSignatures);

      // Format signatures for different output types
      const formattedText = filteredSignatures.map(sig => 
        this.formatSignatureForText(sig, showTimestamp, showUserRole)
      );

      const htmlSignatures = filteredSignatures.map(sig => 
        this.formatSignatureForHTML(sig, showTimestamp, showUserRole)
      );

      return {
        signatures: filteredSignatures,
        formattedText,
        htmlSignatures
      };
    } catch (error) {
      console.error('Error getting signatures for PDF:', error);
      return {
        signatures: [],
        formattedText: [],
        htmlSignatures: []
      };
    }
  }

  /**
   * Format signature for plain text (jsPDF, etc.)
   */
  private static formatSignatureForText(
    signature: AuditTrailEntry,
    showTimestamp: boolean = true,
    showUserRole: boolean = true
  ): string {
    const action = this.getActionLabel(signature.action);
    const user = signature.signature.userName;
    const role = showUserRole ? ` (${signature.signature.userRole})` : '';
    const timestamp = showTimestamp ? ` on ${new Date(signature.timestamp).toLocaleDateString()}` : '';
    
    return `${action} ${user}${role}${timestamp}`;
  }

  /**
   * Format signature for HTML (web-based PDFs)
   */
  private static formatSignatureForHTML(
    signature: AuditTrailEntry,
    showTimestamp: boolean = true,
    showUserRole: boolean = true
  ): string {
    const action = this.getActionLabel(signature.action);
    const user = signature.signature.userName;
    const role = showUserRole ? ` <span style="color: #6b7280;">(${signature.signature.userRole})</span>` : '';
    const timestamp = showTimestamp ? ` <span style="color: #9ca3af;">on ${new Date(signature.timestamp).toLocaleDateString()}</span>` : '';
    
    return `<span style="font-size: 12px; color: #374151;">${action} <strong>${user}</strong>${role}${timestamp}</span>`;
  }

  /**
   * Get user-friendly action label
   */
  private static getActionLabel(action: string): string {
    if (action.includes('created')) return 'Created by';
    if (action.includes('updated')) return 'Updated by';
    if (action.includes('payment') || action.includes('paid')) return 'Payment collected by';
    if (action.includes('collect') || action.includes('received')) return 'Items received by';
    if (action.includes('approved')) return 'Approved by';
    if (action.includes('cancelled')) return 'Cancelled by';
    if (action.includes('recorded')) return 'Recorded by';
    if (action.includes('generated')) return 'Generated by';
    return 'Processed by';
  }

  /**
   * Add signatures to HTML content (for web-based PDF generation)
   */
  static async addSignaturesToHTML(
    htmlContent: string,
    recordType: RecordType,
    recordId: string,
    options: Partial<PDFSignatureOptions> = {}
  ): Promise<string> {
    try {
      const signatureData = await this.getSignaturesForPDF(recordType, recordId, options);
      
      if (signatureData.htmlSignatures.length === 0) {
        return htmlContent;
      }

      const signatureSection = `
        <div class="digital-signatures" style="margin-top: 20px; padding: 15px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #3b82f6;">
          <h4 style="margin: 0 0 10px 0; font-size: 14px; color: #1f2937;">Digital Signatures</h4>
          <div style="space-y: 5px;">
            ${signatureData.htmlSignatures.map(sig => `<div style="margin-bottom: 5px;">${sig}</div>`).join('')}
          </div>
        </div>
      `;

      // Insert before closing body tag or at the end
      if (htmlContent.includes('</body>')) {
        return htmlContent.replace('</body>', `${signatureSection}</body>`);
      } else {
        return htmlContent + signatureSection;
      }
    } catch (error) {
      console.error('Error adding signatures to HTML:', error);
      return htmlContent;
    }
  }

  /**
   * Generate signature footer for jsPDF documents
   */
  static async addSignaturesToJsPDF(
    doc: any, // jsPDF instance
    recordType: RecordType,
    recordId: string,
    options: Partial<PDFSignatureOptions> = {}
  ): Promise<void> {
    try {
      const signatureData = await this.getSignaturesForPDF(recordType, recordId, options);
      
      if (signatureData.formattedText.length === 0) {
        return;
      }

      const {
        position = 'footer',
        fontSize = 8,
        color = '#666666'
      } = options;

      const pageHeight = doc.internal.pageSize.height;
      const pageWidth = doc.internal.pageSize.width;
      const margin = 15;

      // Set font properties
      doc.setFontSize(fontSize);
      doc.setTextColor(color);

      if (position === 'footer') {
        // Add signatures at the bottom of the page
        let yPosition = pageHeight - margin - (signatureData.formattedText.length * 5) - 10;
        
        // Add title
        doc.setFont('helvetica', 'bold');
        doc.text('Digital Signatures:', margin, yPosition);
        yPosition += 5;
        
        // Add signatures
        doc.setFont('helvetica', 'normal');
        signatureData.formattedText.forEach(signature => {
          doc.text(signature, margin + 5, yPosition);
          yPosition += 4;
        });
      } else if (position === 'header') {
        // Add signatures at the top of the page
        let yPosition = margin + 20;
        
        doc.setFont('helvetica', 'bold');
        doc.text('Digital Signatures:', margin, yPosition);
        yPosition += 5;
        
        doc.setFont('helvetica', 'normal');
        signatureData.formattedText.forEach(signature => {
          doc.text(signature, margin + 5, yPosition);
          yPosition += 4;
        });
      } else if (position === 'custom' && options.customPosition) {
        // Add signatures at custom position
        let yPosition = options.customPosition.y;
        
        doc.setFont('helvetica', 'bold');
        doc.text('Digital Signatures:', options.customPosition.x, yPosition);
        yPosition += 5;
        
        doc.setFont('helvetica', 'normal');
        signatureData.formattedText.forEach(signature => {
          doc.text(signature, options.customPosition!.x + 5, yPosition);
          yPosition += 4;
        });
      }
    } catch (error) {
      console.error('Error adding signatures to jsPDF:', error);
    }
  }

  /**
   * Generate signature block for React-PDF documents
   */
  static async getSignatureBlockForReactPDF(
    recordType: RecordType,
    recordId: string,
    options: Partial<PDFSignatureOptions> = {}
  ): Promise<{
    signatures: AuditTrailEntry[];
    component: any; // React component
  }> {
    try {
      const signatureData = await this.getSignaturesForPDF(recordType, recordId, options);
      
      if (signatureData.signatures.length === 0) {
        return {
          signatures: [],
          component: null
        };
      }

      // This would be used in React-PDF components
      const component = {
        signatures: signatureData.signatures,
        formattedText: signatureData.formattedText
      };

      return {
        signatures: signatureData.signatures,
        component
      };
    } catch (error) {
      console.error('Error getting signature block for React-PDF:', error);
      return {
        signatures: [],
        component: null
      };
    }
  }

  /**
   * Utility function to check if a record has signatures
   */
  static async hasSignatures(recordType: RecordType, recordId: string): Promise<boolean> {
    try {
      const signatures = await DigitalSignatureService.getSignaturesForRecord(recordType, recordId);
      return signatures && signatures.length > 0;
    } catch (error) {
      console.error('Error checking for signatures:', error);
      return false;
    }
  }

  /**
   * Get signature summary for display
   */
  static async getSignatureSummary(
    recordType: RecordType,
    recordId: string
  ): Promise<{
    count: number;
    latestAction: string;
    latestUser: string;
    latestTimestamp: string;
  }> {
    try {
      const signatures = await DigitalSignatureService.getSignaturesForRecord(recordType, recordId);
      
      if (!signatures || signatures.length === 0) {
        return {
          count: 0,
          latestAction: '',
          latestUser: '',
          latestTimestamp: ''
        };
      }

      const latest = signatures[0]; // Assuming sorted by timestamp desc
      
      return {
        count: signatures.length,
        latestAction: this.getActionLabel(latest.action),
        latestUser: latest.signature.userName,
        latestTimestamp: new Date(latest.timestamp).toLocaleDateString()
      };
    } catch (error) {
      console.error('Error getting signature summary:', error);
      return {
        count: 0,
        latestAction: '',
        latestUser: '',
        latestTimestamp: ''
      };
    }
  }
} 